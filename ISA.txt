    16-Bit Architecture
	

	== REGISTERS =================
	
		R0		General Purpose	(Input/Output)
		R1		General Purpose	(Input)
		R2		General Purpose
		R3		General Purpose
		R4		General Purpose
		R5/SP	Stack Pointer
		R6/LR	Link Register
		R7/PC	Program Counter and Flags
		
	==============================
	
	
	== INSTRUCTION SET ===========
	
	OPCODE	INSTR	PARAMETERS			MACHINE CODE ([11:0])							EXAMPLE ASSEMBLY CODE

	0000	B		PC <- PC + imm12	imm12[11:0]                                     B Label
	
	0001	BEQ		PC <- PC + imm11	0[11], imm11[10:0]                              BEQ Label
            BNE     PC <- PC + imm11    1[11], imm11[10:0]                              BNE Label
	
	0010	BGT		PC <- PC + imm11	0[11], imm11[10:0]                              BGT Label
            BLT     PC <- PC + imm11	0[11], imm11[10:0]                              BLT Label
	
	0011	LDR		DR <- [SR]			00[11:10], DR[9:7], SR[6:4], 0[3:0]				LDR DR, [SR]
	    			DR <- [SR, OR]		01[11:10], DR[9:7], SR[6:4], OR[3:1], 0[0]		LDR DR, [SR, OR]
	    			DR <- [SR, imm4]	10[11:10], DR[9:7], SR[6:4], imm4[3:0]			LDR DR, [SR, #imm4]
	    			DR <- =label		11[11:10], DR[9:7], label[6:0]					LDR DR, =Label
	
	0100	STR		SR -> [DR]			00[11:10], SR[9:7], DR[6:4], 0[3:0]				STR SR, [DR]
	    			SR -> [DR, OR]		01[11:10], SR[9:7], DR[6:4], OR[3:1], 0[0]		STR SR, [DR, OR]
	    			SR -> [DR, imm4]	10[11:10], SR[9:7], DR[6:4], imm4[3:0]			STR SR, [DR, #imm4]
	
	0101	MOV*	DR <- SR			0[11], DR[10:8], SR[7:5]						MOV DR, SR
                    DR <- imm8			1[11], DR[10:8], imm8[7:0]						MOV DR, #imm8
	
	0110	AND*	DR <- DR & SR		0[11], DR[10:8], SR[7:5], 0[4,0]				AND DR, SR
	    			DR <- SR1 & SR2		1[11], DR[10:8], SR1[7:5], SR2[4:2], 0[1:0]		AND DR, SR1, SR2
	
	0111	OR*		DR <- DR | SR		0[11], DR[10:8], SR[7:5], 0[4,0]				OR DR, SR
	    			DR <- SR1 | SR2		1[11], DR[10:8], SR1[7:5], SR2[4:2], 0[1:0]		OR DR, SR1, SR2
	
	1000	NOT*	DR <- ~DR			DR[11:9], 0[8:0]								NOT DR
	
	1001	ADD*	DR <- SR1 + SR2     0[11], DR[10:8], SR1[7:5], SR2[4:2], 0[1:0]     ADD DR, SR1, SR2
                    DR <- SR + imm5     1[11], DR[10:8], SR[7:5], imm5[4:0]             ADD DR, SR, #imm5
	
	1010	SUB*	DR <- SR1 - SR2     0[11], DR[10:8], SR1[7:5], SR2[4:2], 0[1:0]     SUB DR, SR1, SR2
                    DR <- SR - imm5     1[11], DR[10:8], SR[7:5], imm5[4:0]             SUB DR, SR, #imm5
	
	1011	CMP*	NZP(SR1, SR2)       0[11], SR1[10:8], SR2[7:5], 0[4:0]              CMP SR1, SR2
                    NZP(SR, imm8)       1[11], SR[10:8], imm8[7:0]                      CMP SR, #imm8
	
	1100	PUSH	[SP] <- SR          SR[11:9], 0[8:0]                                PUSH {SR}
	
	1101	POP		DR <- [SP]          DR[11:9], 0[8:0]                                POP {DR}
	
	1110	--
	
	1111	HALT
	
	
	Note.
        *: Instruction Modifies Flags
		DR: Destination Register
		SR: Source Register (1 or 2)
		OR: Offset Register
	
	==============================
	
	
	== MEMORY MAP ================
	
	000-399: ROM
	400-999: RAM
	
	Addressability: 8-Bits
	Address Space: 100 Locations
	Endianness: Little
	
	==============================
	
	
	
	
	